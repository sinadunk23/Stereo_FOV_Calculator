<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Camera Resolution & Object Visualizer</title>
    <style>
        body { margin: 0; font-family: sans-serif; display: flex; height: 100vh; background: #f4f4f4; }
        #ui-panel { width: 340px; padding: 20px; background: #fff; border-right: 1px solid #ccc; overflow-y: auto; }
        #viz-container { flex-grow: 1; position: relative; }
        .control-group { margin-bottom: 12px; }
        label { display: block; font-size: 10px; font-weight: bold; color: #555; margin-bottom: 4px; }
        input { width: 100%; box-sizing: border-box; }
        input[type="range"] { margin-top: 6px; }
        .stats { background: #eef7ff; padding: 14px; border-radius: 8px; border: 1px solid #b3d7ff; margin-top: 15px; }
        .stats-header { display:flex; align-items:center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
        .stats-header-title { font-size: 12px; font-weight: 900; color: #0b2b44; letter-spacing: 0.2px; text-transform: uppercase; }
        .copy-btn {
            border: 1px solid rgba(180,190,200,0.9);
            background: rgba(255,255,255,0.95);
            color: #0b2b44;
            font-weight: 900;
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 10px;
            cursor: pointer;
        }
        .copy-btn:hover { background: rgba(240,248,255,0.95); }
        .copy-btn:active { transform: translateY(1px); }
        .stats-grid { display: grid; gap: 10px; }
        .stats-section { background: rgba(255,255,255,0.55); border: 1px solid rgba(179,215,255,0.8); border-radius: 8px; padding: 10px; }
        .stats-title { font-size: 11px; font-weight: 800; color: #0b3d66; letter-spacing: 0.2px; margin-bottom: 8px; text-transform: uppercase; }
        .stat-row { display: flex; align-items: baseline; justify-content: space-between; gap: 10px; margin: 4px 0; }
        .stat-label { font-size: 12px; color: #2b4a66; }
        .stat-value { font-size: 12px; color: #0b2b44; font-weight: 800; text-align: right; }
        .stat-value.primary { font-size: 14px; }
        .stat-unit { font-size: 11px; color: #2b4a66; margin-left: 6px; font-weight: 600; }
        .stat-right { display: flex; align-items: baseline; justify-content: flex-end; gap: 4px; }
        .pill { display: inline-block; padding: 2px 8px; border-radius: 999px; font-size: 11px; font-weight: 800; border: 1px solid transparent; }
        .pill.ok { background: rgba(45,164,78,0.14); color: #1a7f37; border-color: rgba(45,164,78,0.35); }
        .pill.bad { background: rgba(207,34,46,0.12); color: #b42318; border-color: rgba(207,34,46,0.35); }
        .pill.warn { background: rgba(210,153,34,0.14); color: #8a5a00; border-color: rgba(210,153,34,0.35); }

        #view-panel {
            position: absolute;
            top: 12px;
            right: 12px;
            display: grid;
            gap: 8px;
            padding: 8px;
            border-radius: 10px;
            background: rgba(255,255,255,0.78);
            border: 1px solid rgba(180,190,200,0.65);
            backdrop-filter: blur(6px);
            z-index: 5;
            user-select: none;
        }
        #view-panel-title {
            font-size: 11px;
            font-weight: 900;
            letter-spacing: 0.3px;
            color: #0b2b44;
            padding: 2px 4px 0 4px;
            text-transform: uppercase;
        }
        #view-panel-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .view-btn.secondary {
            font-weight: 900;
            background: rgba(240,248,255,0.95);
        }
        .view-btn {
            border: 1px solid rgba(180,190,200,0.9);
            background: rgba(255,255,255,0.9);
            color: #0b2b44;
            font-weight: 800;
            font-size: 12px;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
        }
        .view-btn:hover { background: rgba(240,248,255,0.95); }
        .view-btn:active { transform: translateY(1px); }
    </style>
</head>
<body>
<div id="ui-panel">
    <h3>Camera & Object Calc</h3>
    
    <div class="control-group">
        <label>Working Distance (mm)</label>
        <input type="number" id="wd" value="1000" min="50" max="5000" step="1">
        <input type="range" id="wd-r" value="1000" min="50" max="5000" step="1">
    </div>
    
    <div class="control-group">
        <label>Focal Length (mm)</label>
        <input type="number" id="focal" value="12" min="1" max="100" step="0.1">
        <input type="range" id="focal-r" value="12" min="1" max="100" step="0.1">
    </div>

    <div class="control-group">
        <label>Sensor Width (mm)</label>
        <input type="number" id="sw" value="7.07" min="1" max="50" step="0.01">
        <input type="range" id="sw-r" value="7.07" min="1" max="50" step="0.01">
    </div>

    <div class="control-group">
        <label>Sensor Height (mm)</label>
        <input type="number" id="sh" value="5.30" min="1" max="50" step="0.01">
        <input type="range" id="sh-r" value="5.30" min="1" max="50" step="0.01">
    </div>

    <div class="control-group">
        <label>Horizontal Pixels</label>
        <input type="number" id="px-h" value="2048" min="64" max="12000" step="1">
        <input type="range" id="px-h-r" value="2048" min="64" max="12000" step="1">
    </div>

    <div class="control-group">
        <label>Vertical Pixels</label>
        <input type="number" id="px-v" value="1536" min="64" max="12000" step="1">
        <input type="range" id="px-v-r" value="1536" min="64" max="12000" step="1">
    </div>

    <hr>
    <h4 style="margin: 10px 0 8px 0;">Depth of Field</h4>

    <div class="control-group">
        <label>Aperture (f/#)</label>
        <input type="number" id="fnum" value="8" min="0" max="64" step="0.1">
        <input type="range" id="fnum-r" value="8" min="0" max="64" step="0.1">
    </div>

    <div class="control-group">
        <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="coc-auto" checked style="width:auto;">
            Auto CoC = sensor diagonal / 1500 (industrial)
        </label>
    </div>

    <div class="control-group">
        <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="coc-2px" style="width:auto;">
            2-Pixel Rule CoC = 2 × pixel size (stricter)
        </label>
    </div>

    <div class="control-group">
        <label>Circle of Confusion (µm)</label>
        <input type="number" id="coc-um" value="3.5" min="0.5" max="200" step="0.1">
        <input type="range" id="coc-um-r" value="3.5" min="0.5" max="200" step="0.1">
    </div>

    <div class="control-group">
        <label style="display:flex; align-items:center; gap:8px;">
            <input type="checkbox" id="focus-lock" checked style="width:auto;">
            Lock focus distance to Working Distance
        </label>
    </div>

    <div class="control-group">
        <label>Focus Distance (mm)</label>
        <input type="number" id="focus" value="1000" min="50" max="5000" step="1">
        <input type="range" id="focus-r" value="1000" min="50" max="5000" step="1">
    </div>

    <hr>
    <h4 style="margin: 10px 0 8px 0;">3D Box in Field</h4>
    <div class="control-group">
        <label>Box Width X (mm)</label>
        <input type="number" id="box-w" value="200" min="1" max="5000" step="1">
        <input type="range" id="box-w-r" value="200" min="1" max="5000" step="1">
    </div>

    <div class="control-group">
        <label>Box Depth Z (mm)</label>
        <input type="number" id="box-d" value="200" min="1" max="5000" step="1">
        <input type="range" id="box-d-r" value="200" min="1" max="5000" step="1">
    </div>

    <div class="control-group">
        <label>Box Height Y (mm)</label>
        <input type="number" id="box-h" value="200" min="0" max="5000" step="1">
        <input type="range" id="box-h-r" value="200" min="0" max="5000" step="1">
    </div>

    <div class="stats">
        <div class="stats-header">
            <div class="stats-header-title">Results</div>
            <button class="copy-btn" id="copy-results" type="button" title="Copy all results to clipboard">Copy Results</button>
        </div>
        <div class="stats-grid">
            <div class="stats-section">
                <div class="stats-title">Field of View</div>
                <div class="stat-row">
                    <div class="stat-label">FOV @ WD</div>
                    <div class="stat-right"><span class="stat-value primary" id="fov-mm">0 × 0</span><span class="stat-unit">mm</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Angular FOV</div>
                    <div class="stat-right"><span class="stat-value" id="fov-deg">0° × 0°</span></div>
                </div>
            </div>

            <div class="stats-section">
                <div class="stats-title">Resolution</div>
                <div class="stat-row">
                    <div class="stat-label">Resolution (H)</div>
                    <div class="stat-right"><span class="stat-value primary" id="res-pxmm-h">0</span><span class="stat-unit">mm/px</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Resolution (V)</div>
                    <div class="stat-right"><span class="stat-value" id="res-pxmm-v">0</span><span class="stat-unit">mm/px</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Min Detectable (3px)</div>
                    <div class="stat-right"><span class="stat-value" id="min-feat">0</span><span class="stat-unit">mm</span></div>
                </div>
            </div>

            <div class="stats-section">
                <div class="stats-title">Depth of Field</div>
                <div class="stat-row">
                    <div class="stat-label">DOF (near → far)</div>
                    <div class="stat-right">
                        <span class="stat-value" id="dof-near">0</span>
                        <span class="stat-value" style="opacity:0.7;">→</span>
                        <span class="stat-value" id="dof-far">0</span>
                        <span class="stat-unit">mm</span>
                    </div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Working Range (DOF)</div>
                    <div class="stat-right"><span class="stat-value" id="dof-range">0</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Hyperfocal</div>
                    <div class="stat-right"><span class="stat-value" id="hyperfocal">0</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">CoC Used</div>
                    <div class="stat-right"><span class="stat-value" id="coc-used">0</span></div>
                </div>
            </div>

            <div class="stats-section">
                <div class="stats-title">Box</div>
                <div class="stat-row">
                    <div class="stat-label">Box Fit (corners in FOV)</div>
                    <div class="stat-right"><span class="stat-value" id="box-fit">0/8</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Box Res (bottom H×V)</div>
                    <div class="stat-right"><span class="stat-value" id="box-res-bot">0 × 0</span><span class="stat-unit">mm/px</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Box Res (top H×V)</div>
                    <div class="stat-right"><span class="stat-value" id="box-res-top">0 × 0</span><span class="stat-unit">mm/px</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Box Distance Span</div>
                    <div class="stat-right"><span class="stat-value" id="box-dist-span">0</span></div>
                </div>
                <div class="stat-row">
                    <div class="stat-label">Box In Focus</div>
                    <div class="stat-right"><span class="pill warn" id="box-focus">n/a</span></div>
                </div>
            </div>
        </div>
    </div>
</div>
<div id="viz-container">
    <div id="view-panel">
        <div id="view-panel-title">View Panel</div>
        <div id="view-panel-buttons">
            <button class="view-btn" id="view-top" title="Top view">Top</button>
            <button class="view-btn" id="view-bottom" title="Bottom view">Bottom</button>
            <button class="view-btn" id="view-left" title="Left view">Left</button>
            <button class="view-btn" id="view-right" title="Right view">Right</button>
            <button class="view-btn" id="view-front" title="Front view">Front</button>
            <button class="view-btn" id="view-back" title="Back view">Back</button>
            <button class="view-btn" id="view-iso" title="Isometric view">Iso</button>
            <button class="view-btn secondary" id="take-screenshot" title="Download PNG screenshot">Screenshot</button>
        </div>
    </div>
</div>

<script type="importmap"> { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } } </script>
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    const container = document.getElementById('viz-container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf4f6f8);
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth/container.clientHeight, 1, 10000);
    camera.position.set(500, 2000, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0, 0);
    controls.update();

    const viewState = {
        // updated inside update() for better framing
        wd: 1000,
        fovW: 1000,
        fovH: 800,
        boxW: 200,
        boxD: 200,
        boxH: 200,
    };

    function sceneScale() {
        const w = Math.max(viewState.fovW, viewState.boxW, viewState.boxD, 250);
        const h = Math.max(viewState.wd, viewState.boxH, 250);
        return Math.max(w, h) * 1.15;
    }

    function animateView(toPos, toTarget, ms = 250) {
        const fromPos = camera.position.clone();
        const fromTarget = controls.target.clone();
        const t0 = performance.now();

        (function step(now) {
            const t = Math.min(1, (now - t0) / ms);
            // easeOutCubic
            const e = 1 - Math.pow(1 - t, 3);
            camera.position.lerpVectors(fromPos, toPos, e);
            controls.target.lerpVectors(fromTarget, toTarget, e);
            controls.update();
            if (t < 1) requestAnimationFrame(step);
        })(t0);
    }

    function setQuickView(kind) {
        const d = sceneScale();
        const target = new THREE.Vector3(0, Math.max(0, viewState.boxH / 2), 0);
        const eps = 0.001;

        let pos;
        if (kind === 'top') pos = new THREE.Vector3(0, target.y + d, eps);
        else if (kind === 'bottom') pos = new THREE.Vector3(0, target.y - d, eps);
        else if (kind === 'left') pos = new THREE.Vector3(-d, target.y + d * 0.05, 0);
        else if (kind === 'right') pos = new THREE.Vector3(d, target.y + d * 0.05, 0);
        else if (kind === 'front') pos = new THREE.Vector3(0, target.y + d * 0.05, d);
        else if (kind === 'back') pos = new THREE.Vector3(0, target.y + d * 0.05, -d);
        else /* iso */ pos = new THREE.Vector3(d * 0.85, target.y + d * 0.65, d * 0.85);

        animateView(pos, target, 260);
    }

    (function bindQuickViews() {
        const map = [
            ['view-top', 'top'],
            ['view-bottom', 'bottom'],
            ['view-left', 'left'],
            ['view-right', 'right'],
            ['view-front', 'front'],
            ['view-back', 'back'],
            ['view-iso', 'iso'],
        ];
        for (const [id, kind] of map) {
            const b = document.getElementById(id);
            if (!b) continue;
            b.addEventListener('click', () => setQuickView(kind));
        }
    })();

    (function bindScreenshot() {
        const btn = document.getElementById('take-screenshot');
        if (!btn) return;
        btn.addEventListener('click', () => {
            try {
                // Ensure the latest frame is in the buffer
                renderer.render(scene, camera);

                const prev = btn.innerText;
                btn.innerText = 'Copying...';

                const canvas = renderer.domElement;
                canvas.toBlob(async (blob) => {
                    try {
                        if (!blob) throw new Error('Canvas toBlob() returned null');

                        // Copy image to clipboard (requires secure context + user gesture in most browsers)
                        if (navigator.clipboard && window.ClipboardItem) {
                            const item = new ClipboardItem({ 'image/png': blob });
                            await navigator.clipboard.write([item]);
                            btn.innerText = 'Copied';
                            setTimeout(() => { btn.innerText = prev; }, 900);
                            return;
                        }

                        // Fallback: download if clipboard image copy isn't available
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        const ts = new Date().toISOString().replace(/[:.]/g, '-');
                        a.href = url;
                        a.download = `camera_view_${ts}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);

                        btn.innerText = 'Saved';
                        setTimeout(() => { btn.innerText = prev; }, 900);
                    } catch (e) {
                        console.error('Clipboard screenshot failed', e);
                        btn.innerText = 'Failed';
                        setTimeout(() => { btn.innerText = prev; }, 1200);
                    }
                }, 'image/png');
            } catch (e) {
                console.error('Screenshot failed', e);
                const prev = btn.innerText;
                btn.innerText = 'Failed';
                setTimeout(() => { btn.innerText = prev; }, 1200);
            }
        });
    })();

    const camGroup = new THREE.Group();
    const camBody = new THREE.Mesh(new THREE.BoxGeometry(50,50,70), new THREE.MeshLambertMaterial({color: 0xcccccc}));
    camGroup.add(camBody);
    scene.add(camGroup);
    
    const frustum = new THREE.Mesh(
        new THREE.BufferGeometry(),
        new THREE.MeshBasicMaterial({color: 0x007bff, transparent:true, opacity:0.12, side:THREE.DoubleSide})
    );
    scene.add(frustum);

    const fovPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 1),
        new THREE.MeshBasicMaterial({ color: 0x007bff, transparent: true, opacity: 0.10, side: THREE.DoubleSide })
    );
    fovPlane.rotation.x = -Math.PI / 2;
    scene.add(fovPlane);

    const fovOutline = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.PlaneGeometry(1, 1)),
        new THREE.LineBasicMaterial({ color: 0x1f6feb, linewidth: 1 })
    );
    fovOutline.rotation.x = -Math.PI / 2;
    scene.add(fovOutline);

    const fovPlaneTop = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 1),
        new THREE.MeshBasicMaterial({ color: 0x8b5cf6, transparent: true, opacity: 0.08, side: THREE.DoubleSide })
    );
    fovPlaneTop.rotation.x = -Math.PI / 2;
    scene.add(fovPlaneTop);

    const fovOutlineTop = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.PlaneGeometry(1, 1)),
        new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 1 })
    );
    fovOutlineTop.rotation.x = -Math.PI / 2;
    scene.add(fovOutlineTop);

    // Focus plane (at focus distance)
    const focusPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(1, 1),
        new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.10, side: THREE.DoubleSide })
    );
    focusPlane.rotation.x = -Math.PI / 2;
    scene.add(focusPlane);

    const focusOutline = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.PlaneGeometry(1, 1)),
        new THREE.LineBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.85, linewidth: 1 })
    );
    focusOutline.rotation.x = -Math.PI / 2;
    scene.add(focusOutline);

    // Depth-of-field visualization volume (frustum segment between near/far planes)
    const dofVolume = new THREE.Mesh(
        new THREE.BufferGeometry(),
        new THREE.MeshBasicMaterial({
            color: 0x2da44e,
            transparent: true,
            opacity: 0.10,
            side: THREE.DoubleSide,
            depthWrite: false,
        })
    );
    scene.add(dofVolume);

    const dofOutline = new THREE.LineSegments(
        new THREE.BufferGeometry(),
        new THREE.LineBasicMaterial({ color: 0x2da44e, transparent: true, opacity: 0.65 })
    );
    scene.add(dofOutline);

    const boxMaterial = new THREE.MeshLambertMaterial({ color: 0xd29922, transparent: true, opacity: 0.55 });
    const boxMesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), boxMaterial);
    scene.add(boxMesh);

    const light = new THREE.DirectionalLight(0xffffff, 1); light.position.set(10,20,10); scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));
    scene.add(new THREE.GridHelper(2000, 40, 0xaab4be, 0xd8dde3));
    scene.add(new THREE.AxesHelper(250));

    const lastGood = {
        wd: 1000,
        focal: 12,
        sw: 7.07,
        sh: 5.3,
        pxh: 2048,
        pxv: 1536,
        fnum: 8,
        cocUmManual: 3.5,
        focus: 1000,
        boxW: 200,
        boxD: 200,
        boxH: 200,
    };

    function readFinite(id, key) {
        const el = document.getElementById(id);
        if (!el) return lastGood[key];
        const v = parseFloat(el.value);
        if (Number.isFinite(v)) lastGood[key] = v;
        return lastGood[key];
    }

    function setText(id, text) {
        const el = document.getElementById(id);
        if (el) el.innerText = text;
    }

    function setPill(id, text, state) {
        const el = document.getElementById(id);
        if (!el) return;
        el.innerText = text;
        el.classList.remove('ok', 'bad', 'warn');
        if (state) el.classList.add(state);
    }

    function setValue(id, value) {
        const el = document.getElementById(id);
        if (el) el.value = String(value);
    }

    function getText(id) {
        const el = document.getElementById(id);
        return el ? (el.innerText || '').trim() : '';
    }

    async function copyToClipboard(text) {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(text);
            return;
        }
        // Fallback for non-secure contexts (file:// etc.)
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        ta.style.top = '0';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        document.body.removeChild(ta);
    }

    function buildResultsText() {
        const lines = [];
        const now = new Date();
        lines.push(`Camera & Object Calc — Results`);
        lines.push(`Generated: ${now.toISOString()}`);
        lines.push('');

        lines.push(`Field of View`);
        lines.push(`- FOV @ WD: ${getText('fov-mm')} mm`);
        lines.push(`- Angular FOV: ${getText('fov-deg')}`);
        lines.push('');

        lines.push(`Resolution`);
        lines.push(`- Resolution (H): ${getText('res-pxmm-h')} mm/px`);
        lines.push(`- Resolution (V): ${getText('res-pxmm-v')} mm/px`);
        lines.push(`- Min Detectable (3px): ${getText('min-feat')} mm`);
        lines.push('');

        lines.push(`Depth of Field`);
        lines.push(`- DOF (near → far): ${getText('dof-near')} → ${getText('dof-far')} mm`);
        lines.push(`- Working Range (DOF): ${getText('dof-range')}`);
        lines.push(`- Hyperfocal: ${getText('hyperfocal')}`);
        lines.push(`- CoC Used: ${getText('coc-used')}`);
        lines.push('');

        lines.push(`Box`);
        lines.push(`- Box Fit (corners in FOV): ${getText('box-fit')}`);
        lines.push(`- Box Res (bottom H×V): ${getText('box-res-bot')} mm/px`);
        lines.push(`- Box Res (top H×V): ${getText('box-res-top')} mm/px`);
        lines.push(`- Box Distance Span: ${getText('box-dist-span')}`);
        lines.push(`- Box In Focus: ${getText('box-focus')}`);

        return lines.join('\n');
    }

    function bindNumberAndRange(id) {
        const num = document.getElementById(id);
        const range = document.getElementById(`${id}-r`);
        if (!num || !range) return;

        // initialize slider to match number input
        range.value = num.value;

        num.addEventListener('input', () => {
            range.value = num.value;
            update();
        });

        range.addEventListener('input', () => {
            num.value = range.value;
            update();
        });
    }

    function update() {
        const wd = readFinite('wd', 'wd');
        const f = readFinite('focal', 'focal');
        const sw = readFinite('sw', 'sw');
        const sh = readFinite('sh', 'sh');
        const pxh = readFinite('px-h', 'pxh');
        const pxv = readFinite('px-v', 'pxv');
        const fnum = readFinite('fnum', 'fnum');
        const boxW = readFinite('box-w', 'boxW');
        const boxD = readFinite('box-d', 'boxD');
        const boxH = readFinite('box-h', 'boxH');
        const boxX = 0;
        const boxZ = 0;

        const focusLockEl = document.getElementById('focus-lock');
        const focusLocked = focusLockEl ? !!focusLockEl.checked : true;
        const focus = focusLocked ? wd : readFinite('focus', 'focus');
        if (focusLocked) {
            // Keep the focus inputs visually in sync with WD
            setValue('focus', wd);
            setValue('focus-r', wd);
        }

        // Guard against transient invalid input states (e.g. typing, empty input)
        if (![wd, f, sw, sh, pxh, pxv, fnum, focus, boxW, boxD, boxH].every(Number.isFinite)) {
            return;
        }

        const cocAutoEl = document.getElementById('coc-auto');
        const coc2pxEl = document.getElementById('coc-2px');
        const cocAuto = cocAutoEl ? !!cocAutoEl.checked : true;
        const coc2px = coc2pxEl ? !!coc2pxEl.checked : false;
        const cocManual = !(cocAuto || coc2px);

        const cocUmManual = cocManual ? readFinite('coc-um', 'cocUmManual') : lastGood.cocUmManual;

        if (![cocUmManual].every(Number.isFinite)) {
            return;
        }

        if (wd <= 0 || f <= 0 || sw <= 0 || sh <= 0 || pxh <= 0 || pxv <= 0 || fnum <= 0 || focus <= 0 || boxW <= 0 || boxD <= 0 || boxH < 0) {
            return;
        }
        if (cocManual && cocUmManual <= 0) {
            return;
        }

        camGroup.position.set(0, wd, 0);
        camGroup.rotation.x = -Math.PI/2;

        const fovW = (sw * wd) / f;
        const fovH = (sh * wd) / f;

        // Keep view framing state up to date for quick views
        viewState.wd = wd;
        viewState.fovW = fovW;
        viewState.fovH = fovH;
        viewState.boxW = boxW;
        viewState.boxD = boxD;
        viewState.boxH = boxH;
        // Resolution in mm/px (invert from px/mm)
        const mmppH = fovW / pxh;
        const mmppV = fovH / pxv;

        const angFovH = 2 * Math.atan(sw / (2 * f));
        const angFovV = 2 * Math.atan(sh / (2 * f));

        // Depth of Field (industrial CoC options; distances in mm)
        // - Auto (industrial): CoC = sensor diagonal / 1500 (mm)
        // - 2-pixel rule: CoC = 2 × pixel pitch (mm)
        // - Manual: user-specified CoC (µm)
        const pixelPitchMm = ((sw / pxh) + (sh / pxv)) / 2.0;
        const cocMm = cocAuto
            ? (Math.sqrt(sw * sw + sh * sh) / 1500.0)
            : (coc2px ? (2.0 * pixelPitchMm) : (cocUmManual / 1000.0));

        const H = (f * f) / (fnum * cocMm) + f; // hyperfocal
        const s = focus; // focus distance

        // Near/Far limits per provided python implementation
        const nearDen = (H + s - (2 * f));
        const nearDOF = nearDen !== 0 ? (s * (H - f)) / nearDen : NaN;
        const farDOF = (s >= H) ? Infinity : ((H - s) !== 0 ? (s * (H - f)) / (H - s) : Infinity);
        const dofRange = Number.isFinite(farDOF) ? (farDOF - nearDOF) : Infinity;

        // Visual Frustum
        const pts = [new THREE.Vector3(-fovW/2, 0, -fovH/2), new THREE.Vector3(fovW/2, 0, -fovH/2), new THREE.Vector3(fovW/2, 0, fovH/2), new THREE.Vector3(-fovW/2, 0, fovH/2)];
        frustum.geometry.setFromPoints([new THREE.Vector3(0,wd,0), pts[0], pts[1], new THREE.Vector3(0,wd,0), pts[1], pts[2], new THREE.Vector3(0,wd,0), pts[2], pts[3], new THREE.Vector3(0,wd,0), pts[3], pts[0]]);

        // Working-distance imaging plane
        // NOTE: PlaneGeometry is XY in local space; we rotate it onto XZ with rotation.x,
        // so "height" must scale local Y (not Z).
        fovPlane.scale.set(fovW, fovH, 1);
        fovOutline.scale.set(fovW, fovH, 1);
        fovPlane.position.set(0, 0, 0);
        fovOutline.position.set(0, 0, 0);

        // Focus plane (at focus distance s): in this scene, distance from camera to plane at height y is d = wd - y
        // so yFocus = wd - s. Plane size is physical FOV at distance s.
        const focusValid = focus > 0;
        focusPlane.visible = focusValid;
        focusOutline.visible = focusValid;
        if (focusValid) {
            const yFocus = wd - focus;
            const fovWFocus = (sw * focus) / f;
            const fovHFocus = (sh * focus) / f;
            focusPlane.scale.set(fovWFocus, fovHFocus, 1);
            focusOutline.scale.set(fovWFocus, fovHFocus, 1);
            focusPlane.position.set(0, yFocus, 0);
            focusOutline.position.set(0, yFocus, 0);
        }

        // Box + top-plane FOV (at the box top height)
        const boxTopY = Math.max(0, boxH);
        const dTop = wd - boxTopY;
        const topValid = dTop > 0;
        const fovWTop = topValid ? (sw * dTop) / f : 0;
        const fovHTop = topValid ? (sh * dTop) / f : 0;

        fovPlaneTop.visible = topValid && boxTopY > 0;
        fovOutlineTop.visible = topValid && boxTopY > 0;
        if (fovPlaneTop.visible) {
            fovPlaneTop.scale.set(fovWTop, fovHTop, 1);
            fovPlaneTop.position.set(0, boxTopY, 0);

            fovOutlineTop.scale.set(fovWTop, fovHTop, 1);
            fovOutlineTop.position.set(0, boxTopY, 0);
        }

        boxMesh.scale.set(Math.max(1e-6, boxW), Math.max(1e-6, boxH), Math.max(1e-6, boxD));
        boxMesh.position.set(0, boxH / 2, 0);

        setText('res-pxmm-h', mmppH.toFixed(4));
        setText('res-pxmm-v', mmppV.toFixed(4));
        setText('fov-mm', `${fovW.toFixed(1)} × ${fovH.toFixed(1)}`);
        setText('fov-deg', `${THREE.MathUtils.radToDeg(angFovH).toFixed(1)}° × ${THREE.MathUtils.radToDeg(angFovV).toFixed(1)}°`);
        setText('min-feat', `${Math.max(3 * mmppH, 3 * mmppV).toFixed(3)} (worst axis)`);

        setText('dof-near', Number.isFinite(nearDOF) ? nearDOF.toFixed(1) : 'n/a');
        setText('dof-far', Number.isFinite(farDOF) ? farDOF.toFixed(1) : '∞');
        setText('dof-range', Number.isFinite(dofRange) ? `${dofRange.toFixed(1)} mm` : '∞');
        setText('hyperfocal', `${H.toFixed(1)} mm`);
        const cocModeLabel = cocAuto ? 'auto (diag/1500)' : (coc2px ? `2px (pitch ${(pixelPitchMm * 1000).toFixed(2)} µm)` : 'manual');
        setText('coc-used', `${cocMm.toFixed(4)} mm (${(cocMm * 1000).toFixed(2)} µm) — ${cocModeLabel}`);

        // Show the CoC currently being used in the CoC input field when an auto option is active.
        // Preserve last manual value so switching back to manual restores it.
        if (cocAuto || coc2px) {
            const cocUmUsed = cocMm * 1000.0;
            setValue('coc-um', cocUmUsed.toFixed(2));
            setValue('coc-um-r', cocUmUsed.toFixed(2));
        } else {
            setValue('coc-um', cocUmManual);
            setValue('coc-um-r', cocUmManual);
        }

        // DOF visualization (as a frustum segment). In this scene, distance from camera to a plane at height y is d = wd - y.
        // So a DOF distance d maps to y = wd - d.
        const nearDist = nearDOF;
        const farDistViz = Number.isFinite(farDOF) ? farDOF : wd; // cap "infinity" at the ground plane for visualization

        const dofVizValid = Number.isFinite(nearDist) && nearDist > 0 && farDistViz > nearDist;
        dofVolume.visible = dofVizValid;
        dofOutline.visible = dofVizValid;

        if (dofVizValid) {
            const yNear = wd - nearDist;
            const yFar = wd - farDistViz;

            const wNear = (sw * nearDist) / f;
            const hNear = (sh * nearDist) / f;
            const wFar = (sw * farDistViz) / f;
            const hFar = (sh * farDistViz) / f;

            const n0 = new THREE.Vector3(-wNear / 2, yNear, -hNear / 2);
            const n1 = new THREE.Vector3( wNear / 2, yNear, -hNear / 2);
            const n2 = new THREE.Vector3( wNear / 2, yNear,  hNear / 2);
            const n3 = new THREE.Vector3(-wNear / 2, yNear,  hNear / 2);

            const f0 = new THREE.Vector3(-wFar / 2, yFar, -hFar / 2);
            const f1 = new THREE.Vector3( wFar / 2, yFar, -hFar / 2);
            const f2 = new THREE.Vector3( wFar / 2, yFar,  hFar / 2);
            const f3 = new THREE.Vector3(-wFar / 2, yFar,  hFar / 2);

            // Build triangles for a frustum segment: near face, far face, and 4 side faces
            const verts = [
                // near face (n0,n1,n2) (n0,n2,n3)
                n0, n1, n2,  n0, n2, n3,
                // far face (f2,f1,f0) (f3,f2,f0) (reverse winding)
                f2, f1, f0,  f3, f2, f0,
                // sides
                // n0-n1-f1-f0
                n0, n1, f1,  n0, f1, f0,
                // n1-n2-f2-f1
                n1, n2, f2,  n1, f2, f1,
                // n2-n3-f3-f2
                n2, n3, f3,  n2, f3, f2,
                // n3-n0-f0-f3
                n3, n0, f0,  n3, f0, f3,
            ];

            const pos = new Float32Array(verts.length * 3);
            for (let i = 0; i < verts.length; i++) {
                pos[i * 3 + 0] = verts[i].x;
                pos[i * 3 + 1] = verts[i].y;
                pos[i * 3 + 2] = verts[i].z;
            }

            dofVolume.geometry.dispose();
            dofVolume.geometry = new THREE.BufferGeometry();
            dofVolume.geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            dofVolume.geometry.computeVertexNormals();

            // Outline edges (near rect + far rect + 4 connectors)
            const edgePts = [
                n0, n1,  n1, n2,  n2, n3,  n3, n0,
                f0, f1,  f1, f2,  f2, f3,  f3, f0,
                n0, f0,  n1, f1,  n2, f2,  n3, f3,
            ];
            const edgePos = new Float32Array(edgePts.length * 3);
            for (let i = 0; i < edgePts.length; i++) {
                edgePos[i * 3 + 0] = edgePts[i].x;
                edgePos[i * 3 + 1] = edgePts[i].y;
                edgePos[i * 3 + 2] = edgePts[i].z;
            }
            dofOutline.geometry.dispose();
            dofOutline.geometry = new THREE.BufferGeometry();
            dofOutline.geometry.setAttribute('position', new THREE.BufferAttribute(edgePos, 3));
        }

        // Box focus check: top is closest point (wd - boxTopY), bottom is farthest point (wd - 0)
        const boxNearDist = dTop; // mm from camera to box top plane
        const boxFarDist = wd;    // mm from camera to box bottom plane
        const boxSpanText = topValid
            ? `${boxNearDist.toFixed(1)} → ${boxFarDist.toFixed(1)} mm`
            : `n/a (top ≥ camera)`;
        setText('box-dist-span', boxSpanText);

        const inFocus = topValid &&
            Number.isFinite(nearDOF) &&
            boxNearDist >= nearDOF &&
            (Number.isFinite(farDOF) ? (boxFarDist <= farDOF) : true);
        if (!topValid) setPill('box-focus', 'n/a', 'warn');
        else setPill('box-focus', inFocus ? 'YES' : 'NO', inFocus ? 'ok' : 'bad');

        // Effective resolution at bottom vs top of box (perspective)
        const mmppHBot = (sw * wd) / (pxh * f);
        const mmppVBot = (sh * wd) / (pxv * f);
        const mmppHTop = topValid ? (sw * dTop) / (pxh * f) : NaN;
        const mmppVTop = topValid ? (sh * dTop) / (pxv * f) : NaN;

        setText('box-res-bot', `${mmppHBot.toFixed(4)} × ${mmppVBot.toFixed(4)}`);
        setText('box-res-top', topValid
            ? `${mmppHTop.toFixed(4)} × ${mmppVTop.toFixed(4)}`
            : `n/a (top ≥ camera)`);

        // Estimate "how much fits" by checking box corner points against the physical frustum
        const hw = boxW / 2;
        const hh = boxH / 2;
        const hd = boxD / 2;
        const corners = [
            new THREE.Vector3(boxX - hw, boxH - 0, boxZ - hd),
            new THREE.Vector3(boxX + hw, boxH - 0, boxZ - hd),
            new THREE.Vector3(boxX + hw, boxH - 0, boxZ + hd),
            new THREE.Vector3(boxX - hw, boxH - 0, boxZ + hd),
            new THREE.Vector3(boxX - hw, 0, boxZ - hd),
            new THREE.Vector3(boxX + hw, 0, boxZ - hd),
            new THREE.Vector3(boxX + hw, 0, boxZ + hd),
            new THREE.Vector3(boxX - hw, 0, boxZ + hd),
        ];

        function halfExtentsAtY(y) {
            const d = wd - y;
            if (d <= 0) return { halfW: -1, halfH: -1 };
            return { halfW: (sw * d) / (2 * f), halfH: (sh * d) / (2 * f) };
        }

        let inside = 0;
        for (const p of corners) {
            if (p.y < 0 || p.y > wd) continue;
            const { halfW, halfH } = halfExtentsAtY(p.y);
            if (halfW <= 0 || halfH <= 0) continue;
            if (Math.abs(p.x) <= halfW && Math.abs(p.z) <= halfH) inside++;
        }

        setText('box-fit', `${inside}/8`);
        if (inside === 8) boxMaterial.color.setHex(0x2da44e);
        else if (inside === 0) boxMaterial.color.setHex(0xcf222e);
        else boxMaterial.color.setHex(0xd29922);
    }

    // Pair up all number inputs with their sliders
    [
        'wd','focal','sw','sh','px-h','px-v',
        'fnum','coc-um','focus',
        'box-w','box-d','box-h'
    ].forEach(bindNumberAndRange);

    (function bindFocusLock() {
        const lock = document.getElementById('focus-lock');
        const focusNum = document.getElementById('focus');
        const focusRange = document.getElementById('focus-r');
        if (!lock || !focusNum || !focusRange) return;

        function applyLockUI() {
            const disabled = !!lock.checked;
            focusNum.disabled = disabled;
            focusRange.disabled = disabled;
        }

        lock.addEventListener('change', () => {
            applyLockUI();
            update();
        });
        applyLockUI();
    })();

    (function bindCocAuto() {
        const lock = document.getElementById('coc-auto');
        const coc2px = document.getElementById('coc-2px');
        const cocNum = document.getElementById('coc-um');
        const cocRange = document.getElementById('coc-um-r');
        if (!lock || !coc2px || !cocNum || !cocRange) return;

        function applyLockUI() {
            const disabled = !!lock.checked || !!coc2px.checked;
            cocNum.disabled = disabled;
            cocRange.disabled = disabled;
        }

        lock.addEventListener('change', () => {
            if (lock.checked) coc2px.checked = false;
            applyLockUI();
            update();
        });
        coc2px.addEventListener('change', () => {
            if (coc2px.checked) lock.checked = false;
            applyLockUI();
            update();
        });
        applyLockUI();
    })();

    (function bindCopyResults() {
        const btn = document.getElementById('copy-results');
        if (!btn) return;
        btn.addEventListener('click', async () => {
            const text = buildResultsText();
            try {
                await copyToClipboard(text);
                const prev = btn.innerText;
                btn.innerText = 'Copied!';
                setTimeout(() => { btn.innerText = prev; }, 900);
            } catch (e) {
                console.error('Copy failed', e);
                const prev = btn.innerText;
                btn.innerText = 'Copy failed';
                setTimeout(() => { btn.innerText = prev; }, 1200);
            }
        });
    })();

    update();
    (function anim(){ requestAnimationFrame(anim); renderer.render(scene, camera); })();

    window.addEventListener('resize', () => {
        renderer.setSize(container.clientWidth, container.clientHeight);
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
    });
</script>
</body>

</html>
